//----------CHALLENGE - DECK FACTORY---------------------------------------------------

//function that creates a full deck of cards
//matching values to suits
function makeDeck() {
    const deck = [];
    const suits = ['hearts', 'diamonds', 'spades', 'clubs'];
    const values = '2,3,4,5,6,7,8,9,10,J,Q,K,A';
    
    //iterating through each value in the string values
    for(let value of values.split(',')){
        //then iterating through each suit for each value
        for(let suit of suits){
            //adding an obj to the array deck
            //containing the current value and suit
            deck.push({value, suit});
        }
    }
    //after all iterations are done, return the whole deck
    //should contain 52 objects, each one representing a card
    return deck;
}

//cannot make use of the deck generated by makeDeck() without
//adding the returned deck to a const, and can only have one deck
//at a time, plus it makes code messy if I want to have more functions
//applied to the deck

//creating an object with multiple methods allows me to refer to
//the deck itself in all these methods by using the keywork this

const myDeck = {
    //myDeck properties
    deck: [],
    suits: ['hearts', 'diamonds', 'spades', 'clubs'],
    values: '2,3,4,5,6,7,8,9,10,J,Q,K,A',
    drawnCards: [],

    //a method to populate the deck property
    initializeDeck(){
        //deconstruct the properties so I don't need to use
        //this.whatever when I need to reference them
        const{suits, values, deck} = this;

        //iterating through each value in the string values
        for(let value of values.split(',')){
            //then iterating through each suit for each value
            for(let suit of suits){
                //adding an obj to the array deck
                //containing the current value and suit
                deck.push({value, suit});
            }
        }
        //don't need to return the deck propety anymore, since
        //the property is already changed and saved that way
        //return deck;
    },

    //a method to shuffle the deck
    shuffleDeck(){
        const {deck} = this;

        //loop over the deck backwards
        for(let i = deck.length - 1; i>0; i--){
            //pick random index before current element
            let j = Math.floor(Math.random() * (i+1));
           
            //swap element in current index (i)
            //with the one at selected random index (j)
            //shorthand way of swapping elements using destructing
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
    },

    //a method to draw a single card
    drawCard(){
        //draw the last card of the deck out and update the deck
        //by taking out this card from it 
        const card = this.deck.pop();
        //add the drawn card to the drawnCards array
        this.drawnCards.push(card);
        //return the card
        return card;
    },
    
    //a method to draw multiple cards, passing the number
    //of cards as parameter to the method - returns an array
    //containing all cards that were drawn
    drawMultiple(numCards){
        const cards = [];
        for(let i = 0; i<numCards; i++){
            cards.push(this.drawCard());
        }
        return cards;
    }
}

//if I wanted to crete multiple decks - not the most optmized approach, but
//using what was covered so far in the course
const makeDeck = () => {
    return {
        //would copy/paste the object myDeck here, including properties and methods
        //to use it I would declare a const that would = makeDeck()
        //each time I'd have a new deck that I could work with separately

        //i.e. const deck1 = makeDeck(); const deck2 = makeDeck();
        //I could initalize, shuffle and draw from deck1 without interfering
        //at all with deck2, and vice versa

        //will come back to this code and write it properly once we get to Prototypes, 
        //Classes, and the New operator
    }
}

