Practice Project - NodeJS Command Line Tools
https://www.udemy.com/course/javascript-beginners-complete-tutorial/learn/lecture/17006892#overview

Goals:
- Introduction to NodeJS.
- Get a handle on the NodeJS Standard Library.
- Get more practice with topics around assync programming and some array methods.

------------------------------------------------------------------------------------

App Overview:
If you run a Linux based machine, or a Mac based machine, or even a Windows machine with a Linux terminal emulator, there's a command that can be run at the terminal to print out the different files and folders inside of some directory -> ls.

ls command can be used in two ways
- no arguments: prints out files and folders in the current directory
- with a path: prints out files and folders in relative or absolute path

In this project, the goal is to use NodeJS to re-implement this basic functionality around the ls command. A version of ls that we can run directly at our terminal, inside of any project or any directory on our machine, and just print out all the files and folders inside there.

------------------------------------------------------------------------------------

How are we going to actually read out files and folder in the directory? At this point we've only been taking a look at Javascript inside the browser, without having any access whatsoever to the user's hard drive.

It all changes with NodeJS!

NodeJS Standard Library Documentation -> nodejs.org/api
At the left hand side, there's a list of libraries or modules inside of the NodeJS Standard Library. We can use these different modules and their code and classes and functions to build out a Node application pretty easily. 

These modules can be used to get access to things on a user's device that we don't usually have access to. For our project, we are going to work with the File System on the user's machine.

In th NodeJS list of modules -> File System
https://nodejs.org/api/fs.html
In this documentation, there's a lot of different functions that can be used to work with the user's file system. We can use the functions and objects from this documetnation to read different files on the user's hard drive, create files, edit files, rename them and so on.

readdir(path[,options],callback) -> function that is going to allow the accomplishment of the app, which is to print out all the files and folders inside of some given directory.

Reads the contents of a directory. The callback gets two arguments (err, files) where files is an array of the names of the files in the directory excluding '.' and '..'.

------------------------------------------------------------------------------------

process.cwd() method -> returns the current working directory of the Node.js process. We are going to use this method when passing the current directory as the path argument to readdir, instead of simply '.', since it has much better cross-platform compatibility.

Note: no need to add a require statment for the process module!
The process module is automatically added into the global scope of every project, so it does not have to be required ahead of time to actually make use of it. This is one of the very few modules that behaves in that way.

------------------------------------------------------------------------------------

Running node program as executable

As for the lastest implementation, in order to run our program from a very far removed directory, we need to run node and then list out the exact path to navigate back over to this project directory just to run the program.

To solve this, we are going to implement a command that we can run and have it print ot the files and folders in the current directory, without the need to run node and pass in the file we want to execute, putting all the path to reach that file when not in the same directory.

To start building any project using Node JS, first we have to build a package.json file. The npm init command is used to create a Node. js project. The npm init command will create a package where the project files will be stored. All the modules you download will be stored in the package.

----------STEP 1: Create package.json file with "bin" section

--> Inside the project directory, run "npm init -y" in the comand prompt (the y flag will simply generate an empty npm project without going through an interactive process)

After running this command, a new file wil be added inside of the project directory -> package.json

This file, overall, describes some of the different qualities of the project (name, version, description, main file, keywords, author, licence)

Besides that, there are two extremely important uses for this package.json file:

- scripts section -> inside this sections we're going to end up writing some different little programs that do some automated tasks inside of the project.

- dependencies -> if we decide to install someone else's code or a dependency into our project, it will be automatically inside of this package.json file, so if we ever decide to share our project with someone else, they can run a single command that will take a look at all dependencies that get listed inside this file and automatically install it for them as well.

The other thing we can do inside this package.json file is to set up a little configuration section that allows us to run some commands and have it to trigger some code inside of our project. -> "bin"

This "bin" section means that we have some binary or, essentially, some executable thing that we want to be able to run inside of our project.
"bin": {
    "program-name": "file that contains the code we want to run"
}

--> Inside the package.json file, add the "bin" section. Then create a command (program-name key) that will run the app.js file.
"bin": {
    "nls": "app.js"
}

----------STEP 2: Change app.js file permissions
----------STEP 3: Add comment to app.js file to allow it to be treated as an executable

These steps shouldn't be required on a Windows machine

--> Inside the project directory, run "chmod +x app.js" in the comand prompt

--> At the very top of the app.js file, add the line #!/usr/bin/env node

This line above is telling our computer we want to use Node to execute the file, as opposed to trying to execute the file directly. 

----------STEP 4: Link our project

--> Inside the project directory, run "npm link" in the comand prompt 

This essentially is going to take our current project and make it available to everywhere, or every directory on our machine -> make it globally available everywhere else

------------------------------------------------------------------------------------

Changing the way the list of folders and files is displayed

As for the lastest implementation, all folders and files inside a given directory are being printed out inside a simple array. There's no differentiation between what is a file and what is a folder. So as for the next step, we want to improve the formatting, by displaying the list is a better format and also color code the things that are being logged.

Our current implementation will make this a challenge. We re using readdir, which returns an array of strings that represents the name of the files and folders, and nothing else (no information on what those things are, just their names).

From the fs module -> lstat(path[,options],callback)
Retrieves the <fs.Stats> for the symbolic link referred to by the path. The callback gets two arguments (err, stats) where stats is a <fs.Stats> object. A <fs.Stats> object provides information about a file. This function is used to get some information about one single file or folder at a time. So for this project we are going to end up having to call lstat multiple times, with every single object that we get back inside of the file names array that we get back from readdir.

There are two methods from the <fs.Stats> class that can be used to check if an object describes a regular file or a folder.

- stats.isDirectory(): Returns true if the <fs.Stats> object describes a file system directory.
NOTE: If the <fs.Stats> object was obtained from fs.lstat(), this method will always return false. This is because fs.lstat() returns information about a symbolic link itself and not the path it resolves to.

-stats.isFile(): Returns true if the <fs.Stats> object describes a regular file.
